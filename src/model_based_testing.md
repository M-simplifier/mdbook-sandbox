# Model-Based Testing

vim-likeエディタのコアは状態を持つため、モデルベーステストが強力です。ここでは「単純なモデル」と「本実装」を並行して進め、結果が一致することを検証します。

## モデルの作り方

- 構造は本実装よりも単純にする
- 重要なのは「仕様として正しいこと」
- 最適化や内部表現は不要

例として、`NonEmpty Text` を直接持つモデルを用意し、カーソル移動・挿入・削除・改行を素直に実装します。

## 比較する対象

- バッファの内容 (各行のText)
- カーソル位置
- モード

行の分割や削除のように状態変化が大きい操作ほど、モデルとの差分が表に出やすく、PBTの価値が上がります。

## 失敗例: 行削除後のカーソル

例えば、行削除の後にカーソル更新を忘れると、次のような失敗になります。

```
*** Failed! Falsified (after 6 tests and 2 shrinks):
commands = [EnterInsert, InsertChar 'a', EnterNormal, DeleteLine, MoveRight]
cursor = Cursor {row = 1, col = 0}
```

この例では、行を削除したのにカーソルが古い行番号のまま残っています。モデルは「削除後は行数が減る」ことを必ず守るため、差分が即座に検出されます。

モデルベーステストは「仕様の抜け」を見つけるための最短ルートです。単発の例示テストでは拾えないパスを短いコマンド列で刺せます。

この3点が一致すれば、少なくとも「振る舞いレベルの正しさ」は保証されます。

## 実装の流れ

1. モデルのデータ型を定義する
2. モデル用の `applyCommandModel` を実装する
3. 初期状態を本実装と揃える
4. ランダムなコマンド列で両者を比較する

モデルが壊れていればPBTが明確に失敗するため、仕様の誤りにも早く気づけます。
